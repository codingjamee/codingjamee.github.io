---
title: "#311[udemy react 강의노트]Authentication"
excerpt: "deploy react Application"
published: true
categories:
  - Blog
tags:
  - [Authentication]

toc: true
toc_sticky: false

date: 2022-11-9
last_modified_at: 2022-11-9
---

<br><br>

# 우리가 개발할 대부분의 웹앱에는 Authentication이 필요하다.

<br><br>
우리가 배워야 할 것들
<br><br>

## 1. How Authentication Works in React Apps

리액트앱에서 사용자인증 하는 법

## 2. Implementing User Authentication

로그인 시 보호된 리소스에 접근하는 법

## 3. Adding Auth Persistence & Auto-Logout

사용자가 페이지를 떠나도 로그인을 유지해주는 법
그리고 일정 시간 이후 로그아웃을 자동으로 하는 법

<br><br>

# 왜 인증Authenticaton이 필요한가?

<br><br>
보호해야 할 정보가 있기 때문이다.  
모든 사이트 이용자나 방문자가 모든 정보에 접근 권한을 가져서는 안 된다.  
change password 버튼을 누르면 로그인한 사용자가 아니면  
API 엔드포인트로 전송된 요청이 성공할 수 없게끔 API 엔드포인트에도 접근 제한을 걸어야 한다.

<br><br>

# 어떻게 인증이 작동하는가?

<br><br>

## 1) Get access / permission

## 2) Send request to protected resource

<br>
접근허가 받기   
<br>
보호된 리소스에 요청보내기
<br><br>
<br><br>
로그인으로 자격증명을 제공하여 접근에 대한 허가를 받을 수 있다.
그러려면 계정을 생성해야 할 것이다.<br><br>

로그인 시 자격증명을 제공하면 데이터가 서버로 전송될 것이다.  
서버에서 데이터베이스를 살펴 사용자 이메일/비번 조합을 확인한다.  
유효성을 확인 받으면 요청을 받은 백엔드 서버가 접근을 허가한다. <br><br>

허가를 받으면 사이트 특정 페이지에 접근할 수 있고,  
필요에 따라 접근허가를 활용해 API 엔드포인트의 다른 보호된 <br>  
리소스에 후속 요청을 보낼 수도 있다.  
<br><br>  
인증은 보통 다음과 같이 작동한다<br>

브라우저에서 리액트 앱이 실행중인 클라이언트와, 백엔드 서버가 있다.<br>
서버사이드 코드는 우리가 직접 작성한 것이거나 타인이 작성한 것이다.<br>
서드파티 API 즉 외부 API일 수도 있고 우리 자체 API일 수도 있다. <br>
우선 이메일/ 비밀번호 조합을 입력해 서버에 요청을 보내면  
서버가 유효성을 확인하고 자격증명을 검증해 후속요청을 허가하거나 거절한다. <br>
그러고 나면 우리가 받은 허가를 활용할 수있다. <br><br>

그걸 활용해서 후속요청을 할 수 있다면 충분한 것인가?  
아니다. API 엔드포인트 같은 보호된 리소스에 접근할 수 없다.  
Yes/No는 위조하기 쉽기 때문이다.<br><br>

자격증명을 받는 서버가 Yes/No로만 응답한다면  
아예 허가받는 절차를 생략하고 직접 Yes/No를 보낼 수도 있다.  
그러므로 응답은 이보다 더 정교해야 한다.  
<br><br>
방법은 두가지가 있을 수 있다.  
서버사이드 세션을 활용하거나 인증토큰을 활용하는 것이다.

<br><br>

## 첫 번째 방법. 서버사이드 세션

<br><br>
전통적이면서도 훌륭한 인증 처리기법이다.  
서버사이드 세션에서는 사용자 접근을 허가한 서버가 허가를 받은 클라이언트,  
즉 특정 사용자의 고유 ID를 저장한다.  
서버가 특정 클라이언트의 고유 ID를 생성하고 저장한다.  
따라서 인증을 거치는 모든 방문자의 고유ID가 서버에 저장된다.  
서버에만이 아니라 클라이언트에게도 저장된다.  
<br><br>
덕분에 서버 응답은 고유 ID까지 포함하게 된다.  
서버와 클라이언트 모두 이 ID를 알고 있다.  
이는 서버에 후속 요청을 보낼 때 함께 첨부된다.  
<br><br>
서버가 ID를 알고 있으므로 ID를 위조할 수 없다.  
임의로 만든 ID는 서버가 못알아보니 접근이 거부되고 후속 요청도 불가하다.
<br><br>

### 그러나 한 가지 단점이 있다.

<br><br>
백엔드와 프론트엔드의 결합이 긴밀하면 아무 이상 없지만 분리 되어 있다면 문제가 있다.  
예를들어 싱글 페이지 앱은 서버 A로, 백엔드 앱의 REST API는 서버 B로 운영 중이라면  
결합이 느슨해서 백엔드 API와 프론트엔드의 싱글페이지 앱은 서로 독립적으로 작동할 것이다.  
<br><br>
또는 우리가 구글 맵스 API처럼 여러 사이트에서 이용할 수 있는 API를 만드는 중이라면  
이 역시 프론트엔드에 긴밀하게 결합하지 못하고 유동적인 상태로 있을 것이다.  
이런 경우 서버에 ID를 저장하면 안된다.  
서버는 상태가 없어야 한다. 접속한 클라이언트의 데이터를 저장 해선 안된다.  
<br><br>
백엔드와 프론트엔드 분리 상태는 특히 싱글페이지 앱 개발에서 자주 맞닥뜨릴 것이기 때문에  
중점적으로 다룰 예정이다.  
이 상황에서는 인증 토큰을 사용하면 된다.  
<br><br>

## 두 번째 방법. 인증 토큰

<br><br>
개념은 얼추 비슷하지만 중요한 차이가 있는데  
사용자가 이메일과 비밀번호로 서버에 자격증명을 보내면  
서버가 그걸 데이터베이스에 저장된 아이디/비번 조합과 비교해  
유효성을 확인하는 것까지는 같다.  
<br><br>

그런데 자격증명이 된다면 서버가 허가 토큰이라는 것을 생성한다.  
안에 데이터가 인코딩 된 아주 긴 문자열이다.  
서버가 특정 알고리즘을 사용해 사용자의 이메일주소를 비롯한 각종 데이터를  
한 문자열로 인코딩하면 나중에 다시 개별 데이터로 디코딩 할 수 있다.
<br><br>
각기 다른 데이터를 이어 붙이는 작업인 것이다.  
토큰은 서버가 특정알고리즘에 따라 생성하는데,  
중요한건 서버만 아는 키를 사용해 데이터를 문자열로 해싱한다는 것이다.  
사용되는 키는 클라이언트는 모르고 서버는 안다.  
<br><br>
토큰은 서버에 저장되지 않고 클라이언트에게 전송되지만  
토큰을 생성하는 방법은 서버만 알고 있다. 그 과정에 키가 쓰이기 때문이다.  
리액트 앱같은 클라이언트는 이 토큰을 후속 요청에 첨부해 서버의 보호된 리소스에 보낸다.  
<br><br>
서버는 세션 기반 기법과 달리 ID를 저장하지 않고도 자신이 생성한 토큰인지 확인할 수 있다.  
토큰 생성에 사용된 개인 키를 아는건 서버 뿐이기 때문이다.  
그래서 보호된 리소스에 접근 요청을 보낼 때 첨부된 토큰의 유효성을 서버가 확인한다.  
자신이 생성한 토큰인지 확인할 수 있기 때문이다.  
토큰이 위조됐거나 다른 키로 생성됐으면 서버가 이를 감지하고 접근을 거부한다.  
<br><br>
서버가 클라이언트를 식별하는 또 다른 보안 방식이다.  
프론트 엔드와 백엔드 분리를 허용하는 기법이기도 하다.  
이번 모듈에서 사용할 방법이기도 하다.

<br><br>
<br><br>

<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
