---
title: "#264[udemy react 강의노트] 리덕스 비동기 코드 작성법"
excerpt: "리덕스와 비동기 코드를 어떻게 함께 사용할 것인가? "
published: true
categories:
  - Blog
tags:
  - [Blog, redux, async, http, request]

toc: true
toc_sticky: false

date: 2020-10-18
last_modified_at: 2020-10-18
---

# 리덕스를 부수효과와 비동기식 코드로 연결하기

> cart에 물품을 추가하면 백엔드 코드에 보내기

<br>장바구니를 편집할 때마다 백엔드 서버에 요청을 보내 업데이트 된 장바구니를 백엔드에 저장하여 다시 로드할 때  
프론트엔드 애플리케이션에서 서버에 저장된 장바구니를 가져와서 로드하고  
화면에 표시할 수 있도록 한다.
<br><br>
문제는 현재 http 요청을 해야하는 파일에는 리덕스를 사용하고 있다.  
왜 문제냐 하면

<br>

```
reducer함수는 side-effect가 없고, 동기식 함수여야 한다.
```

그렇기 때문에 리듀서 함수에는 이런 코드를 작성할 수 없다.
(http 리퀘스트등의 함수)  
상태를 업데이트 한 후 http요청을 보내야 한다.
<br>
<br>
<br>

## 사용할 수 있는 방법

<br>

> 1. 컴포넌트에서 useEffect를 사용해서 하는 방법
> 2. action creator안에서 비동기 코드 또는 side-effect 사용하기

<br>

1. productItem 컴포넌트에서 firebase로 보내자

<br>

문제점은 리덕스로 보낸 데이터를 firebase로 보내지 않고  
장바구니에 추가한 데이터를 그대로 보내는 것이기 때문에  
리듀서에서 했던 작업들을 하지 못하고 그대로 firebase에  
추가만 된다.
<br><br>
예를 들면 이런 로직들이다.
<br><br>
<br><br>

<b>cart-Slice.js 파일 코드 일부 </b>
<br><br>

```jsx


reducers: {
    add(state, action) {
      const newItem = action.payload;
      const existingItem = state.items.find(item => item.id === newItem.id);
      state.totalQuantity++;
      if (!existingItem) {
        state.items.push({
          id: newItem.id,
          price: newItem.price,
          quantity: 1,
          totalPrice: newItem.price,
          name: newItem.title,
        });
      } else {
        existingItem.quantity++;
        existingItem.totalPrice = existingItem.totalPrice + newItem.price;
      }
    },
```

<br><br>
위의 코드는 장바구니에 추가한 지금 제품이 이미 장바구니에 있는지,  
있다면 수량만 추가해 주고, 없다면 그대로 추가해주는 로직이다.
<br><br>
우리가 사용하는 firebase백엔드에는 본 강의에서 배운 프론트엔드 지식만으로는  
(nodejs나 PHP같은 백엔드 지식이 있다면 가능하지만)

위와같이 데이터를 변경하는 로직을 만들 수없다.  
(실무에서 firebase를 사용한다면 서버측 코드를 사용할 수 있다
functions라는 서비스가 이러한 것이다.)

<br><br>
<br><br>

## 백엔드 서버와 프론트엔드 하는 일

<br><br>

백엔드 서버는 http요청과 프론트엔드가 보내는 요청을 통해  
프론트엔드 애플리케이션과 통신한다.  
백엔드 API는 많은 일을 하는데  
예를들면 데이터를 변환시키고 데이터를 저장하는 일 등이다.  
이런 API가 있으면 프론트엔드는 적은 작업을 할 것이다.  
장바구니에 추가해야하는 제품에 대한 데이터와 같은 데이터를 보낼 수도 있다.  
해당 데이터를 백엔드로 보내고 백엔드가 변환을 수행하게 만들고  
프론트엔드에서는 응답을 활용하여  
해당 응답을 저장하기 위해 리듀서에 전달하기도 한다.

그러면 리듀서를 줄이고 백엔드에서 들어온 데이터를 취할 수 있다.  
그 데이터를 리덕스에 저장할 수 있다.
<br><br><br>
그러나 많은 일을 할 때의 백엔드의 이야기다.
그러면 프론트엔드가 많은 일을 해야한다.  
리덕스에 저장하고, 해당 데이터를 준비해 데이터를 변환한다.
<br><br>

### 데이터작업과 변환된 데이터를 백엔드로 보내는 방법

<br><br>

모든 작업을 수행하지 않는 백엔드는 흔한 일이다.  
reducer에서 http요청을 보낼 수도 있지만  
지금까지와는 조금 다른 방식이어야 한다.
<br><br><br><br>
productItem.js 파일에서
useSelector로 업데이트 되기 전의 현재 cart를  
가져올 수 있다.  
그리고 리듀서에서 수행하는 변환을  
<u>state를 변경시키지 않고</u> productItem에서 하게 한다.  
그리고 request 요청을 보낸다.

<br><br>
state를 변경하지 않는 것은 중요한데,  
리덕스 툴킷으로 작성한 slice코드 안에서는  
state를 변경하는 코드를 작성하여도  
변경되지 않도록 immer라는 서드파티 라이브러리가 작동했으나  
여기 productItem같은 일반 컴포넌트 에서는 그런 기능이 없기 때문이다.
<br><br>
만일 state를 변경하는 코드를 사용한다면  
리덕스 스토어의 메모리인 자바스크립트 객체를  
리덕스 몰래 변경하게 된다.
<br><br>
왜냐하면 리듀서 함수 외부에서 그것을 변경할 수 있기 때문이다.
<br><br>
그래서 state를 변경하지 않고 위의 방법으로  
productItem에서 변경하기 전의 cart를 가지고 와서  
새로운 state를 작성하여 리듀서 함수에 보내어  
state를 업데이트 해 주었지만,  
이 방식은 문제가 있다.  
아이템을 추가하는 곳에서도 그렇지만,  
삭제하는 곳에서도 같은 코드를 작성해야 한다.  
export로 코드 중복을 피할 수는 있다.  
<br><br>
그러나 여기엔 또다른 문제점이 있다.  
리듀서에서 변환을 수행하지 않는다.  
그러면 add리듀서와 remove리듀서를 삭제해도 문제없게 되지만,  
리덕스를 사용하는 주요한 방법이라고 할 수 없다.  
코드를 어디에 둘 것인지에 대해 생각해 보면  
Fat Reducers vs Fat Components vs Fat Actions다.

<br><br>
<br><br>

## 우리의 코드를 어디에 둘 것인가?

<br><br>

동기식, 사이드이펙트가 없는 코드는 리듀서에 놓고  
액션 크리에이터나 컴포넌트에는 피하는 것이 좋을 것이다.

비동기식 또는 사이드 이펙트가 있는 코드는  
액션 크리에이터나 컴포넌트를 선택하고  
리듀서를 사용하면 안될 것이다.  
그러면 지금 위에서 보여준 예는  
리듀서 내부가 아니라 컴포넌트에서 데이터 변환을 수행하기 때문에  
최적의 코드가 아닌 것이다.  
<br><br>
<br><br>

### 리덕스와 함께 useEffect 사용하기

<br><br>
<br><br>
새 state를 서버에 동기화 하는 경우,  
프론트엔드의 새 state로 서버를 업데이트 하려고 하는경우,  
순서를 단순히 바꾸면 된다.
<br><br>

- 1 먼저 프론트엔드에서 작업을 하고 리덕스가 스토어를 업데이트 하도록 하면 된다.

* 2 그리고 서버에 요청을 보낸다. 그러나 리듀서 함수 내부에서는 아니다.  
  예를 들어 ProductItem 파일이나 전혀 다른 파일 App.js파일등에서
  하게 할 수 있다.
  <br><br>
  <br><br>

### App 컴포넌트에서 서버에 요청 보내기

<br><br>

```jsx
const cart = useSelector(state => state.cart);
...

useEffect(() => {
         const response = await fetch(
        "https://react-.firebaseio.com/cart.json",
        {
          method: "PUT",
          body: JSON.stringify(cart),
        }
      );

  }, [cart]);
```

<br><br>
여기서는 cart 상태 전체를 useSelector로 가져와서  
변경사항을 수신할 수 있다.  
그리고 cart 상태가 변경될 때마다 http요청을 보낸다  
그러기 위해서 useEffect를 사용해 cart를 dependencies에 추가한다.
<br><br>
그리고 fetch함수를 사용해 firebase에 http 리퀘스트를 보낸다.  
이 때 메서드는 PUT을 사용하는데 POST와 다른 점은  
새 데이터가 데이터 목록에 추가되지 않고  
기존의 데이터를 오버라이드 한다는 것이다.
<br><br>
PUT요청을 보낼 때 기존 cart에 수신 데이터를 오버라이드 한다.  
cart는 리덕스로 가져온 것이고, JSON으로 변환하여  
리퀘스트의 일부로 보낸다.  
<br><br>
useSelctor는 리덕스에 대한 구독을 설정한다.  
리덕스 store가 변경될 때마다 App 컴포넌트가 다시 실행되고,  
최신 state를 받게 된다. 지금의 경우, 최신 cart가 된다.  
useEffect도 다시 평가되고, cart도 변경되면 다시 실행된다.
<br><br>
이제 장바구니가 변경될 때마다 http요청을 보낸다.  
순서를 단순히 바꾸어 cart를 업데이트 하는 로직을 리듀서 안에서 유지 할 수 있다.  

<br><br>
리덕스 스토어를 업데이트 하고  
업데이트 된 저장소를 선택하여 요청을 보내면  
productItem에서의 단순한 코드가 모든 논리를 사용하여  
fat리듀서를 만들어 리덕스 state에 따라 sideEffect를 수행할 수 있게 된다. 