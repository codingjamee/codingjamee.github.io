---
title: "#420[udemy react 강의노트] Props 및 typescript 작업하기"
excerpt: "React typescript project"
published: true
categories:
  - Blog
tags:
  - [React, typescript, project, Props]

toc: true
toc_sticky: false

date: 2022-11-30
last_modified_at: 2022-11-30
---

<br><br>

# React typescript props

<br><br>
그럼 코드에서 입력했던 할 일 목록은 지웁시다  
이제 props를 받아 사용할 겁니다  
제 목표는 이 props에 ‘items’나 ‘todos’ 프로퍼티를 받아서  
목록 항목(list item)으로 넣을 겁니다

<br><br>
여기에 벌써 빨간 밑줄이 생긴 게 보이시죠  
마우스 커서를 올려보면 ‘props’가 선언되었지만  
사용된 적이 없다고 나옵니다

<br><br>

```
'props' is declared but its value is never read
```

<br><br>
props를 사용하지 않고 있다는 경고 메시지입니다  
타입스크립트 프로젝트에 추가된 보조 기능이라  
바닐라 자바스크립트 프로젝트에서는 볼 일이 없었죠  
불필요한 코드가 있으면 알려줍니다  
사용하지 않는 코드가 있으면요
또 이런 경고 메시지도 있습니다

<br><br>

```
Parameter 'props' implicitly has an 'any' type
```

<br><br>
‘props’ 매개변수는 지금 any타입이라는 메시지죠  
여기에 타입을 지정하지 않았다는 뜻입니다  
확실하게 타입을 명시하지 않았죠  
그래서 타입스크립트로부터 어떤 지원도  
받지 못하고 있습니다

<br><br>
타입을 정의하지 않았을 때 타입스크립트가  
이런 메시지를 보내도록 설정할 수 있는 이유죠  
명시적으로 ‘any’ 타입을 지정하면 경고 메시지가 사라집니다

<br><br>

```ts
const Todos = (props: any) => {

```

<br><br>
하지만 명시적으로 타입을 지정하지 않으면  
여러분이 이 타입을 전혀 알아낼 수 없다고 말하는 것처럼 보여서  
타입스크립트가 경고 메시지를 보내는 겁니다  
타입을 설정하지 않고 두면 안되죠  
타입스크립트가 이런 사항을 어디까지 경고하도록  
할 건지는 ‘tsconfig.json’ 에서 설정할 수 있습니다  
이 파일은 좀 나중에 살펴보도록 할게요

<br><br>
지금 여기서 필요한 건 분명히 표시하는 겁니다  
여기서 어떤 props를 받을 건지  
이 함수의 props가 어떤 타입이어야 하는지를요

<br><br>
여기에 타입을 지정하면 되겠죠  
props는 객체 타입이라고 표시할 겁니다

<br><br>

```ts
const Todos = (props: {}) => {
  return <ul>{}</ul>;
};

export default Todos;
```

<br><br>
그래서 중괄호{}를 추가했고요 다시 말하지만 여기엔  
값이 아니라 타입 정의가 들어갑니다 이건 객체 타입이죠  
리액트에서 props는 언제나 객체 형태입니다  
다른 속성들처럼 App.tsx에 있는 요소에  
키-값 쌍 형태로 프로퍼티를 추가합니다

<br><br>
App.tsx 파일
<br><br>

```ts
<Todos />
```

<br><br>
아마 여기서 todos나 items라는 프로퍼티를 받을 거고요  
 형태는 문자열 배열이 될 겁니다

<br><br>

```ts
const Todos = (props: { items: string[] }) => {

```

<br><br>
정리하자면 props는 객체고 items를 키로 가지며  
문자열 배열을 값으로 갖는다는 뜻입니다  
그런데 사실 100% 맞는 말은 아니에요  
props에는 우리가 JSX에서 사용하기 위해  
컴포넌트에 추가한 키-값 쌍만 있는 게 아닙니다

<br><br>
props는 객체이기 때문에 당연히 그런 키-값 쌍도 갖고 있습니다
하지만 객체에는 항상 특별한 프로퍼티(prop)가 있죠  
children 프로퍼티입니다

<br><br>

```ts
const Todos = (props: { items: string[], children }) => {

```

<br><br>
우리는 이 프로퍼티의 타입도 모르죠  
그래서 어떤 타입으로 설정해야 하는지 찾아내  
이런 식으로 추가해야 합니다 매우 귀찮은 일이 되겠죠  
props를 사용하도록 정의한 모든 컴포넌트에 대해  
객체에 미리 정의된 props를 매번 추가해야 한다면 말입니다  
직접 만든 props도 마찬가지고요

<br><br>
이 작업은 번거롭고 모든 컴포넌트가 기본으로 갖는 prop 객체  
예를 들면 children prop 같은 프로퍼티까지 있기 때문에  
리액트는 다른 방법을 제공합니다  
리액트와 타입스크립트가 제공하는 방법이라고 할 수도 있고요

<br><br>
바로 제네릭 타입을 이용하는 겁니다, 아마 기억하실 거예요  
제네릭 타입을 이용해서, 정확히 말하자면  
함수형 컴포넌트를 바로 제네릭 함수로 변환해서 이용하는 겁니다

<br><br>
이 말이 의미하는 바는 우리가 만든 함수형 컴포넌트에서  
몇 가지 설정을 추가하여 리액트 함수형 컴포넌트로 동작하도록 만들어  
children 같은 기본 props를 사용할 수 있도록 하는 겁니다

<br><br>
그런 다음 새로운 props를 추가로 정의합니다  
여기서는 items prop 같은 거겠죠  
새로 추가한 프로퍼티는 props 객체에 합쳐져야 하고요

<br><br>
아직 완벽히 이해되지 않는다면 어떻게 동작하는지 보여드릴게요
화살표 함수(=>) 구문을 사용하겠습니다  
앞선 강의에서는 계속 사용했던 방식이죠  
여기 있는 상수 Todos가  
리액트 함수 컴포넌트를 들고 있습니다

<br><br>
상수 Todos에 타입을 지정할 수 있겠죠  
타입은 ‘React’로 지정해야 합니다  
이를 위해 React를 가져와야 하고요  
react에서요, 그리고 ‘.FC’를 추가합니다  
(project setup에 의해 생략 가능)
이 타입은 리액트 패키지에 정의된 타입입니다

<br><br>

```tsx
import React from "react";

const Todos: React.FC = (props) => {
  return <ul>{}</ul>;
};

export default Todos;
```

<br><br>
정확히는 ‘@types/react’ 패키지에 정의된 거죠  
그래도 ‘import React from ‘react’를 쓰시면 돼요  
나머지는 알아서 처리될 겁니다 이렇게 타입을 정의했습니다

<br><br>
커맨드 키나 컨트롤 키를 누른 상태에서  
여기 ‘FC’를 클릭하면 타입 정의를 볼 수 있습니다  
‘FunctionComponent’라는 타입이네요
이 리액트 패키지에 내장된 또 다른 타입 정의입니다

<br><br>

```ts
type FC<P = {}> = FunctionComponent<P>;
```

<br><br>
이렇게 React.FC라고 타입을 정의함으로써  
이 함수가 함수형 컴포넌트로 동작한다는 걸 명확히 하는 겁니다  
그게 FC의 의미죠, 함수형 컴포넌트(Functional Component)요  
이제 props 밑에 있던 빨간 줄이 사라졌습니다

<br><br>
JSX 코드에서 {props}를 넣고 점을 찍으면 자동 완성 창에  
children 프로퍼티가 나타납니다  
단지, 이 React.FC라는 타입 표기를 추가함으로써  
타입스크립트와 개발 툴은 명석하게도  
이 함수가 받는 값이 props 객체라는 걸 이해하게 됩니다

<br><br>
함수의 첫번째 인자로 받는 값이요  
그리고 props 객체에는 항상 children 프로퍼티가 있죠  
이렇게 이해하고 동작할 수 있는 이유는  
React.FC라는 타입을 지정했기 때문이죠

<br><br>
제네릭 타입이 중요하다고 말씀드린 건 이 자체가  
제네릭 타입이기 때문입니다 이제 우리가  
새로 정의한 타입을 props 객체에 합칠 수 있습니다

<br><br>
이 함수형 컴포넌트를 위해 우리가 만든 props와  
children props 같은 기본적인 props를 합치는 거죠  
<br><br>

이를 위해 FC 뒤에 홑화살괄호(<>)를 추가하겠습니다  
그리고 괄호 사이에 새로 만들 props를 정의하고요

<br><br>

```ts
const Todos: React.FC<{}> = (props) => {

```

<br><br>
여기서는 홑화살괄호를 처음에 제네릭 타입을 소개할 때  
사용했던 것과는 약간 다른 방식으로 사용할 겁니다  
이전에 제네릭 함수를 만들기 위해 홑화살괄호를 사용할 때는  
제네릭 타입 매개변수가 있었죠 이 제네릭 타입 T요

<br><br>
basics.ts파일
<br><br>

```ts
const insertAtBeginning = <T>(array: T[], value: T) => {

```

<br><br>
그리고 함수 안에서 이 타입을 사용되었습니다  
이 예시에서는 우리가 제네릭 함수를  
사용했을 때 타입스크립트가 타입을 추론했죠

<br><br>
여기서는 약간 다르게 사용합니다 React.FC는 이미 제네릭 타입이죠  
리액트 패키지에서 정의한 타입 설명을 보면 제네릭이라고 되어 있어요  
그러니까 이 타입은 이미 내부에서 홑화살괄호를 사용해 정의된 겁니다

<br><br>
이 코드에서 다시 홑화살괄호를 추가한 다음  
‘T’ 같은 식별자를 넣어 새로운 제네릭 타입을 만드는 게 아니라,  
내부적으로 사용되는 제네릭 타입에 구체적인 값을 집어넣을 겁니다
React.FC에 의해 정의된 타입 T에요

<br><br>
이렇게 하는 이유는 여기에서는 타입스크립트가  
제네릭 타입을 추론하게 둘 수 없기 때문입니다,  
앞에 보여드린 예제와 달리요

<br><br>
타입스크립트가 타입을 추론하게 둘 수 없는 건  
매개변수를 넣고 제네릭 함수를 호출해서  
해당 값의 타입을 추론하도록 두는 게 아니라  
<br><br>

```ts

const insertAtBeginning = <T>(array: T[], value: T) => {
```

<br><br>
함수를 정의하고 타입스크립트에게 이 함수를 내부적으로  
어떻게 처리해야 하는지 알려주고 싶기 때문이죠

<br><br>
우리가 추가한 props를 받아서  
모든 함수형 컴포넌트가 갖고 있는 children 프로퍼티 같은  
기본적인 props 들과 합칠 수 있도록요

<br><br>
우리는 여기서 제네릭 타입의 다른 면을 확인한 겁니다,  
제네릭 타입을 사용해서 ‘FC’라는 제네릭 타입의 용도에 맞게  
사용할 하나의 타입을 명시적으로 설정하는 거죠

<br><br>
이 FC 타입은 제네릭 타입이고 거기에 집어넣을 값은  
제가 만든 props 객체입니다, 이 함수형 컴포넌트에 맞게  
props를 정의한 객체죠

<br><br>
이게 제네릭인 이유는 함수형 컴포넌트마다  
props에 대한 정의가 다르기 때문이고요  
이것이 리액트와 타입스크립트를 이용해서  
제네릭 타입을 사용하는 또 다른 방식입니다

<br><br>
이 홑화살괄호 구문은 제네릭 타입을 만드는 구문이죠  
이렇게 추가함으로써 FC 타입 내부의  
기능을 밖으로 꺼낸 겁니다

<br><br>

```ts
const Todos: React.FC<{}> = (props) => {

```

<br><br>
FC 타입의 기능은 여기에 어떤 객체 타입을 정의하든  
객체의 기본 타입, children 프로퍼티와 합쳐주는 기능이고요  
이제 여기에서 items로 문자열 배열을 받도록 설정하고요

<br><br>

```ts
const Todos: React.FC<{items: string[]}> = (props) => {

```

<br><br>
그리고 이제 여기에서 다시 props 뒤에 점을 찍으면,  
여전히 children 프로퍼티가 있다는 걸 알고 있죠  
적어도 children 프로퍼티가 있을 수 있다는 걸요  
그리고 이제는 items 프로퍼티도 있습니다  
타입은 문자열 배열이고요  
<br><br>
이 프로퍼티를 아는 이유는 여기에서  
새로운 프로퍼티의 정의를  
기본 props 객체 정의에 추가했기 때문입니다

<br><br>
모든 게 아주 복잡하게 들리실 겁니다  
하지만 그건 제가 밑단에서 일어나는 일을  
설명하고 있기 때문에 그런 것뿐이에요  
사용하는 건 매우 간단합니다

<br><br>
리액트와 타입스크립트로 함수형 컴포넌트를 만들려면  
React.FC 타입을 함수형 컴포넌트의 상수 옆에 사용합니다  
<br><br>
그리고 홑화살괄호를 붙인 다음 그 괄호 사이에  
필요한 형태의 props를 정의하는 겁니다  
프로퍼티 객체의 타입이요  
컴포넌트에 직접 만든 props가 필요하다면요
그리고 컴포넌트 안에서 직접 만든 props를 사용하면 되죠  
여기서는 items 프로퍼티의 map을 사용할 겁니다

<br><br>
배열을 위한 자동 완성 창도 볼 수 있는데
items가 배열이라는 걸 타입스크립트가 알기 때문이죠
위에서 배열 타입으로 정의했으니까요

<br><br>

```ts
return <ul>{props.items.map()}</ul>;
```

<br><br>
items의 각 item을 list item 요소로 바꿀 수 있습니다,  
여기에 항목을 넣고 키에는 item을 넣겠습니다  
이렇게 하면 키에는 items 배열의 문자열이 들어갈 겁니다

<br><br>

```tsx
const Todos: React.FC<{ items: string[] }> = (props) => {
  return (
    <ul>
      {props.items.map((item) => (
        <li key={item} />
      ))}
    </ul>
  );
};

export default Todos;
```

<br><br>
코드를 재정렬했고요, 이제 Todos 컴포넌트가 완성되었습니다,  
적절한 타입도 표기했고요 리액트에서 타입스크립트를 사용하는 것의 장점은  
코드에서 많은 게 설명된다는 것뿐만 아니라 이 컴포넌트 안에서 작업할 때  
자동 완성 기능도 사용할 수 있다는 겁니다 이걸로도 충분하죠

<br><br>
하지만 이제 App.tsx에 오류가 있습니다  
우리가 추가한 타입 표기 때문에 리액트는 이제 알게 된 겁니다  
정확히는 프로젝트 설정에서 우리가 Todos 컴포넌트를 사용하는 방식이  
잘못됐다는 걸 알게 됩니다

<br><br>
여기 명확하게 표시했으니까요 Todos 컴포넌트의 타입을  
정의하는 부분에 이 컴포넌트는 items 프로퍼티를 갖는다고 정의했죠

<br><br>

```tsx
const Todos: React.FC<{ items: string[] }> = (props) => {

```

<br><br>
이건 선택적으로 설정할 수 있는 prop이 아닙니다  
물음표를 추가해 선택적인 prop으로 만들 수도 있지만  
그렇게 하면 item을 갖지 않는 경우에 대해 처리해 줘야 합니다  
어쨌든 여기서는 할 수 있는 게 없으므로  
App.tsx에서 추가해야 합니다  
타입스크립트를 사용해야 하는 또 다른 이유죠

<br><br>
우리는 컴포넌트의 형태와 해당 컴포넌트에  
필요한 props를 모두 작성했습니다  
그래서 컴포넌트를 잘못된 방식으로 사용하는 일  
예를 들어 컴포넌트에 필요한 props를  
일부만 넘기거나 하는 일은 발생할 수 없습니다  
개발 툴이 바로 이렇게 오류를 알려주기 때문이죠

<br><br>
그럼 이제 items를 추가할 수 있겠네요,  
일단 지금은 테스트로 내용을 추가하겠습니다

‘리액트 공부하기’, ‘타입스크립트 공부하기’ 이렇게요
<br><br>

```tsx
<Todos items={["Learn React", "Learn TypeScript"]} />
```

<br><br>
모든 오류가 사라졌습니다 하지만 이제는 props가 추가되었고  
추가된 props는 정상적으로 동작하며 타입 표기도 추가된 상태죠

<br><br>
새롭게 만들 모든 컴포넌트에 이 타입 표기를 추가하면 됩니다  
props도 새롭게 만들어 사용한다면 이 제네릭 타입을 추가하고  
홑화살괄호 안에 새로운 props의 타입을 정의하면 되죠
